package org.exploit.jettyx;

import org.eclipse.jetty.client.HttpClient;
import org.eclipse.jetty.client.dynamic.HttpClientTransportDynamic;
import org.eclipse.jetty.io.ClientConnectionFactory;
import org.eclipse.jetty.io.ClientConnector;
import org.eclipse.jetty.util.ssl.SslContextFactory;
import org.exploit.jettyx.auth.Authorization;
import org.exploit.jettyx.auth.NoAuth;
import org.exploit.jettyx.core.ServiceInvocationHandler;
import org.exploit.jettyx.core.url.ConstantUrlProvider;
import org.exploit.jettyx.core.url.UrlProvider;
import org.exploit.jettyx.core.version.Http11Version;
import org.exploit.jettyx.core.version.HttpVersionAdapter;
import org.exploit.jettyx.mapper.HttpMapper;
import org.exploit.jettyx.mapper.HttpMapperRegistry;

import java.io.Closeable;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.lang.reflect.Proxy;
import java.util.Comparator;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.function.Consumer;

public class Jettyx implements Closeable {
    private final HttpClient client;
    private final Executor executor;
    private final HttpMapperRegistry mapperRegistry;

    private Jettyx(Builder builder) {
        this.client = createHttpClient(builder);
        this.mapperRegistry = builder.mapperRegistry;
        this.executor = builder.executor;;
    }

    private HttpClient createHttpClient(Builder builder) {
        var sslContextFactory = builder.sslContextFactory != null
                ? builder.sslContextFactory
                : new SslContextFactory.Client();

        var connector = new ClientConnector();
        connector.setSslContextFactory(sslContextFactory);

        var transport = getHttpClientTransportDynamic(builder, connector);
        var httpClient = new HttpClient(transport);

        if (executor != null)
            httpClient.setExecutor(executor);

        if (builder.customizer != null)
            builder.customizer.accept(httpClient);

        try {
            httpClient.start();
        } catch (Exception e) {
            throw new IllegalStateException("Failed to start HttpClient", e);
        }

        return httpClient;
    }

    private static HttpClientTransportDynamic getHttpClientTransportDynamic(Builder builder, ClientConnector connector) {
        var connectionFactories = builder.versions
                .stream()
                .map(adapter -> adapter.getInfo(connector))
                .toArray(ClientConnectionFactory.Info[]::new);

        return new HttpClientTransportDynamic(connector, connectionFactories);
    }

    public ApiClient newApiClient(UrlProvider provider, Authorization auth) {
        return new ApiClient(provider.getUrl(), auth);
    }

    public ApiClient newApiClient(String baseUrl, Authorization auth) {
        return newApiClient(new ConstantUrlProvider(baseUrl), auth);
    }

    public ApiClient newApiClient(String baseUrl) {
        return newApiClient(baseUrl, new NoAuth());
    }

    public static Builder newBuilder() {
        return new Builder();
    }

    @Override
    public void close() {
        try {
            client.stop();
        } catch (Exception e) {
            throw new UncheckedIOException(new IOException(e));
        }
    }

    public class ApiClient {
        private final String baseUrl;
        private final Authorization defaultAuthorization;

        public ApiClient(String baseUrl, Authorization defaultAuthorization) {
            this.baseUrl = baseUrl;
            this.defaultAuthorization = defaultAuthorization;
        }

        @SuppressWarnings("unchecked")
        public <T> T create(Class<T> serviceInterface) {
            var handler = new ServiceInvocationHandler(client, mapperRegistry, baseUrl, defaultAuthorization);
            return (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), new Class<?>[]{serviceInterface}, handler);
        }
    }

    public static class Builder {
        private final HttpMapperRegistry mapperRegistry = new HttpMapperRegistry();

        private final SortedSet<HttpVersionAdapter> versions = new TreeSet<>(Comparator.naturalOrder());
        {
            versions.add(new Http11Version());
        }

        private Consumer<HttpClient> customizer = (client) -> {};

        private SslContextFactory.Client sslContextFactory = new SslContextFactory.Client();

        private Executor executor;

        public Builder addHttpMapper(HttpMapper mapper) {
            this.mapperRegistry.addMapper(mapper);
            return this;
        }

        public Builder enableVersion(HttpVersionAdapter versionAdapter) {
            versions.removeIf(v -> v.version() == versionAdapter.version());
            this.versions.add(versionAdapter);
            return this;
        }

        public Builder sslContextFactory(SslContextFactory.Client sslContextFactory) {
            this.sslContextFactory = sslContextFactory;
            return this;
        }

        public Builder customize(Consumer<HttpClient> customizer) {
            this.customizer = customizer;
            return this;
        }

        public Builder executor(Executor executor) {
            this.executor = executor;
            return this;
        }

        public Jettyx build() {
            return new Jettyx(this);
        }
    }
}