package org.exploit.jettyx.mapper;

import org.exploit.jettyx.exception.InvalidResponseBodyException;

import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

public class ScalarHttpMapper implements HttpMapper {
    public static final Set<Class<?>> SCALAR_TYPES = Set.of(
            String.class, Character.class, Byte.class, Short.class, Integer.class,
            Long.class, Float.class, Double.class, Boolean.class,
            char.class, byte.class, short.class, int.class, long.class, float.class, double.class, boolean.class
    );

    private static final Map<Class<?>, Function<String, Object>> STRING_CONVERSION_FUNCTIONS = Map.of(
            Byte.class, Byte::valueOf,
            byte.class, Byte::parseByte,
            Short.class, Short::valueOf,
            short.class, Short::parseShort,
            Integer.class, Integer::valueOf,
            int.class, Integer::parseInt,
            Long.class, Long::valueOf,
            long.class, Long::parseLong,
            Double.class, Double::valueOf,
            double.class, Double::parseDouble
    );

    @Override
    public boolean canSerialize(Type sourceType) {
        if (sourceType instanceof Class<?> clazz) {
            return SCALAR_TYPES.contains(clazz);
        }
        return false;
    }

    @Override
    public boolean canDeserialize(Type targetType) {
        if (targetType instanceof Class<?> clazz) {
            return SCALAR_TYPES.contains(clazz);
        }
        return false;
    }

    @Override
    public String getContentType() {
        return "text/plain; charset=utf-8";
    }

    @Override
    public Object convert(byte[] body, Type type) {
        try {
            if (type instanceof Class<?> clazz) {
                var str = new String(body);

                var converter = STRING_CONVERSION_FUNCTIONS.get(clazz);

                if (converter != null)
                    return converter.apply(str);
                else if (String.class.equals(clazz) || Character.class.equals(clazz))
                    return str;
            }
            throw new IllegalArgumentException("Unsupported scalar type: " + type);
        } catch (Exception e) {
            throw new InvalidResponseBodyException(body);
        }
    }

    @Override
    public byte[] serialize(Object o) {
        return o.toString().getBytes(StandardCharsets.UTF_8);
    }

    public static ScalarHttpMapper create() {
        return new ScalarHttpMapper();
    }
}