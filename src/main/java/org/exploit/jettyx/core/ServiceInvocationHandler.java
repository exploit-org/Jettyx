package org.exploit.jettyx.core;

import io.github.bucket4j.BlockingStrategy;
import io.github.bucket4j.Bucket;
import org.eclipse.jetty.client.HttpClient;
import org.eclipse.jetty.client.HttpContentResponse;
import org.eclipse.jetty.client.api.ContentResponse;
import org.eclipse.jetty.client.api.Request;
import org.eclipse.jetty.client.api.Result;
import org.eclipse.jetty.client.util.BufferingResponseListener;
import org.eclipse.jetty.client.util.BytesRequestContent;
import org.exploit.jettyx.annotation.*;
import org.exploit.jettyx.auth.Authorization;
import org.exploit.jettyx.auth.NoAuth;
import org.exploit.jettyx.core.url.UrlBuilder;
import org.exploit.jettyx.mapper.HttpMapperRegistry;
import org.exploit.jettyx.model.HttpResponse;

import java.lang.reflect.*;
import java.net.URI;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;
import java.util.function.Supplier;

public class ServiceInvocationHandler implements InvocationHandler {
    private final HttpClient httpClient;
    private final HttpMapperRegistry mapperRegistry;
    private final String baseUrl;
    private final Authorization defaultAuthorization;
    private final Bucket bucket;

    public ServiceInvocationHandler(
        HttpClient httpClient, HttpMapperRegistry mapperRegistry,
        String baseUrl, Authorization defaultAuthorization,
        Bucket bucket
    ) {
        this.httpClient = httpClient;
        this.mapperRegistry = mapperRegistry;
        this.baseUrl = baseUrl;
        this.defaultAuthorization = defaultAuthorization != null ? defaultAuthorization : new NoAuth();
        this.bucket = bucket;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.getDeclaringClass() == Object.class)
            return method.invoke(this, args);

        var requestInfo = extractRequestInfo(method, args);
        var uri = buildUri(requestInfo);

        var jettyRequest = buildRequest(uri, requestInfo);
        requestInfo.getAuthorization().apply(jettyRequest);

        var returnType = getActualReturnType(method);
        var isAsync = methodReturnsCompletableFuture(method);

        return withPermit(() -> {
            if (isAsync) {
                return sendAsyncRequest(jettyRequest, returnType, method);
            } else {
                return sendSyncRequest(jettyRequest, returnType, method);
            }
        });
    }

    private RequestInfo extractRequestInfo(Method method, Object[] args) {
        var requestInfo = new RequestInfo();

        var requestAnnotation = method.getAnnotation(HttpRequest.class);

        if (requestAnnotation == null) {
            throw new IllegalStateException("Method must be annotated with @Request");
        }

        requestInfo.setAuthorization(extractAuthorization(method, args));
        requestInfo.setHttpMethod(requestAnnotation.method());
        requestInfo.setPath(requestAnnotation.path());

        var parameters = method.getParameters();
        for (var i = 0; i < parameters.length; i++) {
            processParameter(parameters[i], args[i], requestInfo);
        }

        return requestInfo;
    }

    private Authorization extractAuthorization(Method method, Object[] args) {
        var parameters = method.getParameters();
        for (var i = 0; i < parameters.length; i++) {
            if (parameters[i].isAnnotationPresent(Auth.class) && args[i] instanceof Authorization) {
                return (Authorization) args[i];
            }
        }
        return defaultAuthorization;
    }

    private void processParameter(Parameter parameter, Object argument, RequestInfo requestInfo) {
        if (parameter.isAnnotationPresent(Header.class)) {
            var headerAnnotation = parameter.getAnnotation(Header.class);
            requestInfo.addHeader(headerAnnotation.value(), argument.toString());
        }

        if (parameter.isAnnotationPresent(HeaderMap.class)) {
            if (argument instanceof Map<?, ?> headerMap) {
                headerMap.forEach((key, value) -> requestInfo.addHeader(key.toString(), value.toString()));
            } else {
                throw new IllegalArgumentException("@HeaderMap parameter must be of type Map");
            }
        }

        if (parameter.isAnnotationPresent(Query.class)) {
            if (argument != null) {
                var queryAnnotation = parameter.getAnnotation(Query.class);
                requestInfo.addQueryParam(queryAnnotation.value(), argument.toString());
            }
        }

        if (parameter.isAnnotationPresent(QueryMap.class)) {
            if (argument instanceof Map<?, ?> queryMap) {
                queryMap.forEach((key, value) -> {
                    if (value != null) {
                        requestInfo.addQueryParam(key.toString(), value.toString());
                    }
                });
            } else {
                throw new IllegalArgumentException("@QueryMap parameter must be of type Map");
            }
        }

        if (parameter.isAnnotationPresent(Path.class)) {
            var pathAnnotation = parameter.getAnnotation(Path.class);
            requestInfo.addPathParam(pathAnnotation.value(), Objects.requireNonNull(argument).toString());
        }

        if (parameter.isAnnotationPresent(Body.class)) {
            requestInfo.setBody(argument);
        }

        if (parameter.isAnnotationPresent(ContentType.class)) {
            var contentTypeAnnotation = parameter.getAnnotation(ContentType.class);
            requestInfo.setContentType(contentTypeAnnotation.value());
        }
    }

    private URI buildUri(RequestInfo requestInfo) {
        var urlBuilder = new UrlBuilder()
                .baseUrl(baseUrl)
                .path(requestInfo.getPath());

        requestInfo.getAuthorization().apply(urlBuilder);
        requestInfo.getPathParams().forEach(urlBuilder::placeholder);
        requestInfo.getQueryParams().forEach(urlBuilder::queryParam);

        return urlBuilder.build();
    }

    private Request buildRequest(URI uri, RequestInfo requestInfo) {
        var jettyRequest = httpClient.newRequest(uri)
                .method(requestInfo.getHttpMethod());

        jettyRequest.headers(mutable -> requestInfo.getHeaders().forEach(mutable::add));

        var body = requestInfo.getBody();

        if (body == null)
            return jettyRequest;

        if (body instanceof Request.Content content) {
            jettyRequest.body(content);
            return jettyRequest;
        }

        Type bodyType = body.getClass();

        var bodyMapper = mapperRegistry.findCanSerialize(bodyType).orElseThrow();
        var contentType = requestInfo.getContentType() == null ? bodyMapper.getContentType()
                : requestInfo.getContentType();

        var serializedBody = bodyMapper.serialize(body);

        jettyRequest.body(new BytesRequestContent(contentType, serializedBody));

        return jettyRequest;
    }

    private CompletableFuture<Object> sendAsyncRequest(Request jettyRequest, Type returnType, Method method) {
        var resultFuture = new CompletableFuture<>();

        jettyRequest.send(new BufferingResponseListener() {
            @Override
            public void onComplete(Result result) {
                if (result.isSucceeded()) {
                    try {
                        var contentResponse = new HttpContentResponse(result.getResponse(),
                                getContent(), getMediaType(), getEncoding());

                        var responseBody = handleResponse(contentResponse, returnType, method);

                        if (!resultFuture.isDone())
                            resultFuture.complete(responseBody);
                    } catch (Exception e) {
                        resultFuture.completeExceptionally(e);
                    }
                } else {
                    resultFuture.completeExceptionally(result.getFailure());
                }
            }
        });

        return resultFuture;
    }

    private Object sendSyncRequest(Request jettyRequest, Type returnType, Method method) {
        try {
            var response = jettyRequest.send();
            return handleResponse(response, returnType, method);
        } catch (ExecutionException | TimeoutException e) {
            throw new IllegalStateException(e);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IllegalStateException(e);
        }
    }

    private Object handleResponse(ContentResponse contentResponse, Type returnType, Method method) {
        var responseMapper = mapperRegistry.findCanDeserialize(returnType).orElseThrow();
        var responseBody = responseMapper.convert(contentResponse.getContent(), returnType);

        if (methodReturnsHttpResponse(method)) {
            return new HttpResponse<>(
                    contentResponse.getStatus(),
                    contentResponse.getHeaders(),
                    responseBody,
                    contentResponse
            );
        }

        return responseBody;
    }

    private Type getActualReturnType(Method method) {
        var returnType = method.getGenericReturnType();

        if (methodReturnsCompletableFuture(method)) {
            if (returnType instanceof ParameterizedType parameterizedType) {
                var completableFutureType = parameterizedType.getActualTypeArguments()[0];
                if (isResponseType(completableFutureType)) {
                    return getInnerType(completableFutureType);
                }
                return completableFutureType;
            } else {
                return method.getReturnType();
            }
        }

        if (isResponseType(returnType))
            return getInnerType(returnType);

        return returnType;
    }

    private boolean isResponseType(Type type) {
        if (type instanceof ParameterizedType parameterizedType)
            return parameterizedType.getRawType().equals(HttpResponse.class);

        return false;
    }

    private Type getInnerType(Type responseType) {
        if (responseType instanceof ParameterizedType parameterizedType)
            return parameterizedType.getActualTypeArguments()[0];

        return Object.class;
    }

    private boolean methodReturnsCompletableFuture(Method method) {
        return CompletableFuture.class.isAssignableFrom(method.getReturnType());
    }

    private boolean methodReturnsHttpResponse(Method method) {
        if (methodReturnsCompletableFuture(method)) {
            if (method.getGenericReturnType() instanceof ParameterizedType parameterizedType) {
                var actualType = parameterizedType.getActualTypeArguments()[0];

                if (actualType instanceof ParameterizedType paramType) {
                    return paramType.getRawType().equals(HttpResponse.class);
                } else if (actualType instanceof Class<?> actualClass) {
                    return actualClass.equals(HttpResponse.class);
                }
            }
            return false;
        }

        return method.getReturnType().equals(HttpResponse.class);
    }

    private <T> T withPermit(Supplier<T> supplier) {
        if (bucket == null)
            return supplier.get();

        try {
            bucket.asBlocking().consume(1, BlockingStrategy.PARKING);
            return supplier.get();
        } catch (Exception e) {
            Thread.currentThread().interrupt();
            throw new IllegalStateException("Couldn't acquire permit ", e);
        }
    }
}